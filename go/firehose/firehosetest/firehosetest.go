// Package firehosetest provides test doubles for the StreamingFast Firehose
// service, coupled to EVM code running on a simulated blockchain.
//
// See the tests of the github.com/cxkoda firehose package for example usage.
package firehosetest

import (
	"context"
	"fmt"
	"io"
	"testing"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/google/go-cmp/cmp"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/testing/protocmp"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/timestamppb"

	sfethpb "github.com/streamingfast/firehose-ethereum/types/pb/sf/ethereum/type/v2"
	hosepb "github.com/streamingfast/pbgo/sf/firehose/v2"

	"github.com/cxkoda/solgo/go/ethtest"
	"github.com/cxkoda/solgo/go/grpctest"
	"github.com/cxkoda/solgo/projects/indexing/firehose"

	svcpb "github.com/cxkoda/solgo/projects/indexing/firehose/proto/eth"
	ethpb "github.com/cxkoda/solgo/proto/eth"
)

// A Fake couples a bind.ContractBackend() running a real EVM implementation,
// with a fake Firehose Stream server. Solidity bindings generated by abigen
// can be used to trigger real EVM events that are propagated to the Firehose
// fake.
//
// The Firehose fake can be accessed directly with the RawClient, or abstracted
// with ETH-specific "Hydrant" APIs via the Client. Filtering other than Start-
// and StopBlockNum is not currently supported by the Firehose fake so all
// transactions, in all blocks, are propagated. This MUST NOT be depended upon,
// and is open to breaking changes as the fake's behaviour approaches the real
// Firehose.
type Fake struct {
	sim       *ethtest.SimulatedBackend
	conn      *grpc.ClientConn
	hose      *hose
	Client    svcpb.HydrantServiceClient
	RawClient hosepb.StreamClient
}

// A Config configures new Fakes.
type Config struct {
	// UseETHServer instructs NewFake to call firehose.ETHServer() instead of
	// firehose.ETHClient(). This typically makes no difference, but SHOULD
	// ideally match whichever is to be used in production in case there are
	// edge-case differences. If true, the returned server will be connected to
	// with the grpctest package.
	UseETHServer bool
}

// NewFake returns NewFake() called on a zero Config.
func NewFake(ctx context.Context, tb testing.TB) *Fake {
	var c Config
	return c.NewFake(ctx, tb)
}

// NewFake returns a new Fake, reporting all errors on tb.Fatal.
func (c *Config) NewFake(ctx context.Context, tb testing.TB) *Fake {
	tb.Helper()

	h := new(hose)
	// The firehose proto generates a deprecated registration method that we
	// need to wrap for use with grpctest generic registration.
	reg := func(s *grpc.Server, impl hosepb.StreamServer) {
		hosepb.RegisterStreamServer(s, impl)
	}
	hoseGRPC := grpctest.NewWithRegisteredTB[hosepb.StreamServer](tb, reg, h)
	hoseConn, err := hoseGRPC.Dial()
	if err != nil {
		tb.Fatalf("%T{%T}.Dial() error %v", hoseGRPC, h, err)
	}

	var (
		client  svcpb.HydrantServiceClient
		cleanup func() error
	)
	if c.UseETHServer {
		srv, clean, err := firehose.ETHServer(ctx, "", "", "", hoseGRPC.DialOpts()...)
		if err != nil {
			tb.Fatalf("firehose.ETHServer([dialling grpctest Firehose]) error %v", err)
		}
		conn := grpctest.NewClientConnTB(tb, svcpb.RegisterHydrantServiceServer, srv)
		client = svcpb.NewHydrantServiceClient(conn)
		cleanup = clean
	} else {
		cl, clean, err := firehose.ETHClient(ctx, "", "", "", hoseGRPC.DialOpts()...)
		if err != nil {
			tb.Fatalf("firehose.ETHClient([dialling grpctest Firehose]) error %v", err)
		}
		client = cl
		cleanup = clean
	}
	tb.Cleanup(func() {
		cleanup()
	})

	sim := ethtest.NewSimulatedBackendTB(tb, 1)
	sim.AutoCommit = false

	return &Fake{
		sim:       sim,
		hose:      h,
		Client:    client,
		RawClient: hosepb.NewStreamClient(hoseConn),
	}
}

// Backend returns the ContractBackend running the Fake's EVM.
func (f *Fake) Backend() bind.ContractBackend {
	return f.sim.SimulatedBackend
}

// TxOpts returns TransactOpts for sending transactions to f.Backend().
func (f *Fake) TxOpts() *bind.TransactOpts {
	return f.sim.Acc(0)
}

// RPCClient returns an ethclient.Client connected to the Fake's underlying EVM
// backend.
func (f *Fake) RPCClient(ctx context.Context, tb testing.TB) *ethclient.Client {
	tb.Helper()

	url := f.sim.ServeHTTP(tb)
	c, err := ethclient.DialContext(ctx, url)
	if err != nil {
		tb.Fatalf("ethclient.DialContext(â€¦, %q [URL from %T.ServeHTTP()]) error %v", url, f.sim, err)
	}
	tb.Cleanup(c.Close)
	return c
}

// MineBlock "mines" all transactions sent to f.Backend(). This moves the
// transactions out of the pending state, and queues the block for being
// returned by the Fake's Firehose/Hydrant clients.
//
// This is NOT thread-safe so all blocks MUST be mined before calls to either of
// the gRPC clients.
func (f *Fake) MineBlock(ctx context.Context, tb testing.TB) *types.Block {
	tb.Helper()

	sim := f.sim

	blockHash := sim.Commit()
	block, err := sim.BlockByHash(ctx, blockHash)
	if err != nil {
		// This can only happen if there's a bug in go-ethereum's SimulatedBackend
		// or our extensions thereof.
		tb.Fatalf("%T.BlockByBlockHash(%T.Commit()) error %v", sim, sim, err)
	}

	var txs []*sfethpb.TransactionTrace
	for _, tx := range block.Transactions() {
		rcpt, err := sim.TransactionReceipt(ctx, tx.Hash())
		if err != nil {
			// Similar to above.
			tb.Fatalf("%T.TransactionReceipt([tx hash from just-mined block]) error %v", sim, err)
		}

		var logs []*sfethpb.Log
		for _, l := range rcpt.Logs {
			ev := &sfethpb.Log{
				Address: l.Address.Bytes(),
				Topics:  make([][]byte, len(l.Topics)),
				Data:    l.Data,
				Index:   uint32(l.Index),
			}
			for i, t := range l.Topics {
				ev.Topics[i] = t.Bytes()
			}

			logs = append(logs, ev)
		}

		txs = append(txs, &sfethpb.TransactionTrace{
			Hash: rcpt.TxHash.Bytes(),
			Receipt: &sfethpb.TransactionReceipt{
				Logs: logs,
			},
		})
	}

	f.hose.blocks = append(f.hose.blocks, &sfethpb.Block{
		Hash:              block.Hash().Bytes(),
		Number:            block.NumberU64(),
		TransactionTraces: txs,
		Header: &sfethpb.BlockHeader{
			Timestamp: timestamppb.New(time.Unix(int64(block.Time()), 0)),
		},
	})

	return block
}

// Cursor returns the cursor returned by a fake Firehose for a given block. This
// will change and its stability MUST NOT be depended upon. It is exposed to
// couple test results with their expected values.
func Cursor(b *types.Block) string {
	return blockCursor(b.NumberU64())
}

func blockCursor(num uint64) string {
	return fmt.Sprintf("block[%d]", num)
}

// hose is a fake Firehose server implementation. All calls to Blocks simply
// send every block.
type hose struct {
	blocks []*sfethpb.Block
}

func (h *hose) Blocks(req *hosepb.Request, srv hosepb.Stream_BlocksServer) error {
	if s := req.StartBlockNum; s < 0 {
		return status.Errorf(codes.InvalidArgument, "negative %T.StartBlobkNum = %d", req, s)
	}

	for _, b := range h.blocks {
		if n := b.Number; n < uint64(req.StartBlockNum) {
			continue
		} else if req.StopBlockNum != 0 && n > req.StopBlockNum {
			return nil
		}

		any, err := anypb.New(b)
		if err != nil {
			return fmt.Errorf("[%T] anypb.New(%T): %v", h, b, err)
		}
		resp := &hosepb.Response{
			Block:  any,
			Cursor: blockCursor(b.Number),
		}
		if err := srv.Send(resp); err != nil {
			return fmt.Errorf("[%T] %T.Send(): %v", h, srv, err)
		}
	}
	return nil
}

// CmpOpts returns options for performing diffs between Hydrant.BlockResponse
// test results and expected values.
func CmpOpts() cmp.Options {
	return cmp.Options{
		protocmp.Transform(),
		protocmp.IgnoreEmptyMessages(),
		protocmp.IgnoreMessages(&sfethpb.Block{}),
	}
}

// A HydrantClient can receive BlockResponse protos. It is implemented by both
// of the HydrantService_{EventsClient,ERC721TransferEventsClient} types.
type HydrantClient interface {
	Recv() (*svcpb.BlockResponse, error)
}

// CollectAll calls client.Recv() until an error occurs. If the error is io.EOF
// then all received BlockResponses are returned, otherwise the error is
// reported on tb.Fatal. io.EOF is the standard end-of-stream indicator for
// gRPC stream methods, so indicates a clean close.
func CollectAll(tb testing.TB, client HydrantClient) []*svcpb.BlockResponse {
	tb.Helper()

	var got []*svcpb.BlockResponse
	for {
		b, err := client.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			tb.Fatalf("%T.Recv() error %v", client, err)
		}
		got = append(got, b)
	}
	return got
}

// Arg acts similarly to ethpb.NewArgument(), but allows for concrete types that
// can be unambiguously mapped to ethpb.Value_Payload types. If unmabiguous
// mapping isn't possible, tb.Fatal() will be called.
func Arg(tb testing.TB, name string, val interface{}, indexed bool) *ethpb.Argument {
	tb.Helper()

	v, err := ethpb.AsValue(val)
	if err != nil {
		tb.Fatalf("ethpb.AsValue(%T{%v}) error %v", val, val, err)
	}
	return ethpb.NewArgument(name, v.Payload, indexed)
}
