package ethkms

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/x509/pkix"
	"encoding/asn1"
	"encoding/pem"
	"fmt"
	"math/big"
	"testing"

	"cloud.google.com/go/kms/apiv1/kmspb"
	"github.com/ethereum/go-ethereum/accounts/abi/bind/backends"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"google.golang.org/api/option"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"

	"github.com/proofxyz/solgo/go/eth"
	"github.com/proofxyz/solgo/go/grpctest"
)

// A stubGCP always returns the same PEM when a public key is requested, and
// returns status.Unimplemented when a signing request is made.
type stubGCP struct {
	pem string
	kmspb.KeyManagementServiceServer
}

func (s *stubGCP) GetPublicKey(ctx context.Context, req *kmspb.GetPublicKeyRequest) (*kmspb.PublicKey, error) {
	return &kmspb.PublicKey{
		Algorithm: kmspb.CryptoKeyVersion_EC_SIGN_SECP256K1_SHA256,
		Pem:       s.pem,
	}, nil
}

func (s *stubGCP) AsymmetricSign(ctx context.Context, req *kmspb.AsymmetricSignRequest) (*kmspb.AsymmetricSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "AsymmetricSign not implemented by %T", s)
}

func TestGCPPubKeyDecode(t *testing.T) {
	ctx := context.Background()

	// This test uses a real PEM block returned by a GCP key that was used to
	// sign an actual Goerli transaction.
	//
	// As the complete round-trip test generates a public key and encodes it, we
	// risk circular logic (tests mirroring implementation) so lock in a real
	// test of key decoding here.

	// See https://goerli.etherscan.io/tx/0x9982c97a4f26fa4f90e2ff9a0efcc6ef2b3c84f4a667bf581a84c3a7f36c8ba5
	addr := common.HexToAddress("0xBc26Eb539E671f6788a74D77B8560Bd02Ce4789A")

	const pem = `-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtKaSkxW72USLyV7Au716DLgYW4w+ewWA
/kd1GyPLP048s8Os4zoutKvbwAGl84HhB2SfWbdsJS2CG+uaLSM3zg==
-----END PUBLIC KEY-----`

	conn := grpctest.NewClientConnTB[kmspb.KeyManagementServiceServer](
		t,
		kmspb.RegisterKeyManagementServiceServer,
		&stubGCP{pem: pem},
	)
	gcp, err := NewGCP(ctx, "", big.NewInt(0), option.WithGRPCConn(conn))
	if err != nil {
		t.Fatalf("NewGCP(…, option.WithGRPCConn(%T)) error %v", &stubGCP{}, err)
	}

	if got, want := gcp.Address(), addr; got != want {
		t.Errorf("%T.Address() got %v; want %v", gcp, got, want)
	}
}

// A fakeGCP implements full key generation and asymmetric signing, backed by
// in-process, deterministic keys.
type fakeGCP struct {
	kmspb.KeyManagementServiceServer
}

// keyFromSeed writes the seed to a Keccak256 state, which it then uses as a
// source of entropy for generating a secp256k1 key.
func keyFromSeed(seed string) (*ecdsa.PrivateKey, error) {
	s := crypto.NewKeccakState()
	s.Write([]byte(seed))

	priv, err := ecdsa.GenerateKey(crypto.S256(), s)
	if err != nil {
		return nil, fmt.Errorf("ecdsa.GenerateKey(%T, %T): %v", crypto.S256(), s, err)
	}
	return priv, nil
}

// addressFromSeed returns the address associated with the key generated by
// keyFromSeed if called with the same seed. It reports any errors on t.Fatal.
func addressFromSeed(t *testing.T, seed string) common.Address {
	t.Helper()
	priv, err := keyFromSeed(seed)
	if err != nil {
		t.Fatal(err)
	}
	return crypto.PubkeyToAddress(priv.PublicKey)
}

// GetPublicKey generates a private key using req.Name as the seed and returns
// the respective public key.
func (*fakeGCP) GetPublicKey(ctx context.Context, req *kmspb.GetPublicKeyRequest) (*kmspb.PublicKey, error) {
	priv, err := keyFromSeed(req.Name)
	if err != nil {
		return nil, err
	}
	pub := priv.PublicKey
	pubBytes := elliptic.Marshal(crypto.S256(), pub.X, pub.Y)

	// x509.MarshalPKIXPublicKey() doesn't support secp256k1 so we have to do it
	// ourselves.
	info := struct {
		Algo      pkix.AlgorithmIdentifier
		BitString asn1.BitString
	}{
		Algo: pkix.AlgorithmIdentifier{
			Algorithm: oidECDSAPubKey,
		},
		BitString: asn1.BitString{
			Bytes:     pubBytes,
			BitLength: 8 * len(pubBytes),
		},
	}

	buf, err := asn1.Marshal(info)
	if err != nil {
		return nil, err
	}
	pemBuf := new(bytes.Buffer)
	if err := pem.Encode(pemBuf, &pem.Block{Type: "PUBLIC KEY", Bytes: buf}); err != nil {
		return nil, fmt.Errorf("pem.Encode(…): %v", err)
	}

	return &kmspb.PublicKey{
		Name:      req.Name,
		Algorithm: kmspb.CryptoKeyVersion_EC_SIGN_SECP256K1_SHA256,
		Pem:       pemBuf.String(),
	}, nil
}

// AsymmetricSign generates a private key using req.Name as the seed and returns
// a signature of req.Digest.
func (*fakeGCP) AsymmetricSign(ctx context.Context, req *kmspb.AsymmetricSignRequest) (*kmspb.AsymmetricSignResponse, error) {
	priv, err := keyFromSeed(req.Name)
	if err != nil {
		return nil, err
	}

	// For test stability, we use deterministic "randomness" in creating the
	// signature. It's much easier to debug without changing values.
	rand := crypto.NewKeccakState()
	buf, err := proto.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("proto.Marshal(%T): %v", req, err)
	}
	rand.Write(buf)

	// GCP doesn't know that we're actually using SHA3. Very sneaky ;)
	digest, ok := req.Digest.Digest.(*kmspb.Digest_Sha256)
	if !ok {
		return nil, status.Errorf(codes.InvalidArgument, "unsupported digest type %T; MUST be SHA256", req.Digest.Digest)
	}

	r, s, err := ecdsa.Sign(rand, priv, digest.Sha256)
	if err != nil {
		return nil, fmt.Errorf("ecdsa.Sign(%T, …): %v", rand, err)
	}
	sig := struct{ R, S *big.Int }{
		R: r,
		S: s,
	}
	sigBuf, err := asn1.Marshal(sig)
	if err != nil {
		return nil, fmt.Errorf("asn1.Marshal(%T): %v", sig, err)
	}

	return &kmspb.AsymmetricSignResponse{
		Signature: sigBuf,
	}, nil
}

func TestGCP(t *testing.T) {
	ctx := context.Background()

	const (
		key0 = "my/hsm/key"
		key1 = "another/hsm/key"
	)
	addr0 := addressFromSeed(t, key0)
	addr1 := addressFromSeed(t, key1)

	startBalance := eth.Ether(100)

	alloc := core.GenesisAlloc{
		addr0: core.GenesisAccount{Balance: startBalance},
	}
	sim := backends.NewSimulatedBackend(alloc, 3e7 /* gas limit */)

	wantBal := func(t *testing.T, addr common.Address, want *big.Int) {
		t.Helper()
		got, err := sim.BalanceAt(ctx, addr, nil)
		if err != nil || got.Cmp(want) != 0 {
			t.Logf("Balance delta; got - want = %d", new(big.Int).Sub(got, want))
			t.Fatalf("%T.BalanceAt(ctx, %v, nil) got %d, err=%v; want %d, nil err", sim, addr, got, err, want)
		}
	}
	t.Run("initial balances", func(t *testing.T) {
		wantBal(t, addr0, startBalance)
		wantBal(t, addr1, big.NewInt(0))
	})

	conn := grpctest.NewClientConnTB[kmspb.KeyManagementServiceServer](
		t,
		kmspb.RegisterKeyManagementServiceServer,
		&fakeGCP{},
	)

	chainID := sim.Blockchain().Config().ChainID
	gcp, err := NewGCP(ctx, key0, chainID, option.WithGRPCConn(conn))
	if err != nil {
		t.Fatalf("NewGCP(…, option.WithGRPCConn(%T)) error %v", &fakeGCP{}, err)
	}
	defer gcp.Close()

	sendVal := eth.EtherFraction(1, 4)
	tx := &types.DynamicFeeTx{
		ChainID:   chainID,
		Nonce:     0,
		To:        &addr1,
		Value:     sendVal,
		Gas:       21_000,
		GasTipCap: eth.EtherFraction(1, 1e9),
		GasFeeCap: sim.Blockchain().CurrentBlock().BaseFee,
	}
	signed, err := gcp.SignTx(ctx, types.NewTx(tx))
	if err != nil {
		t.Fatalf("%T.SignTx(ctx, %T{%+v}) error %v", gcp, tx, tx, err)
	}
	t.Logf("Signed tx %#x", signed.Hash().Bytes())

	if err := sim.SendTransaction(ctx, signed); err != nil {
		t.Fatalf("%T.SendTransaction(ctx, %T.SignTx(%T)) error %v", sim, gcp, tx, err)
	}
	sim.Commit()

	mined, pending, err := sim.TransactionByHash(ctx, signed.Hash())
	if err != nil || pending {
		t.Fatalf("%T.TransactionByHash(ctx, %#x) after SendTransaction()+Commit() got pending=%t, err=%v; want false, nil err", sim, signed.Hash().Bytes(), pending, err)
	}

	t.Run("after transfer", func(t *testing.T) {
		wantBal(t, addr0, new(big.Int).Sub(startBalance, mined.Cost()))
		wantBal(t, addr1, sendVal)
	})
}
